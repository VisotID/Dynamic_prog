// Высоцкая И.Д.
#include "Dynamic_pr.h" // подключение заголовочного файла модуля
#include <fstream>
#include <cassert> // библиотека С++ для обнаружения логических ошибок в программе(для функции assert)

/// Функция чтения строки из файла
/// s - название файла, question - считанная строка
void ReadF(const string& s, string& question)
{
    ifstream file(s); // Открываем входной файл
    if (file.is_open()) // Проверяем, успешно ли открыт файл
    {
        string line;
        getline(file, line); // Читаем первую строку
        question = line; // Сохраняем ее в переменную question
    }
    file.close(); // Закрываем файл
}

/// // Функция записи ответа в файл
/// s - название файла, ways - количество способов
void WriteF(const string& s, const int ways)
{
    ofstream file(s); // Открываем выходной файл
    if (file.is_open()) // Проверяем, успешно ли открыт файл
    {
        file << ways; // Записываем число способов
    }
    file.close(); // Закрываем файл
}

/// Функция для подсчета числа правильных скобочных последовательностей
/// question - проверяемая строка, dp - массив для подсчета количества способов
void Ans(const string& question, vector<vector<int>>& dp)
{
    if (question.size() == 0) // если пустая строка
    {
        dp[0][0] = 0;
        return;
    }
    for (int i = 1; i <= int(question.size()); i++) // Проходим по всем позициям строки (от 1 до длины)
    {
        // j - баланс это количество "(" - количество ")" (в любой момент неотрицательный) (в конце баланс = 0 - ответный элемент массива (количество способов))
        for (int j = 0; j <= 80; j++) // Проходим по всем возможным значениям баланса (от 0 до 80)
        {

            if (question[i - 1] == '(') // Если текущий символ — открывающая скобка '('
            {
                if (j > 0) // Баланс должен оставаться неотрицательным
                    dp[i][j] = dp[i - 1][j - 1]; // Увеличиваем баланс: берем способы из j-1
            }

            if (question[i - 1] == ')') // Если текущий символ — закрывающая скобка ')'
                dp[i][j] = dp[i - 1][j + 1]; // Уменьшаем баланс: берем способы из j+1

            if (question[i - 1] == '?') // Если текущий символ — знак вопроса '?'
            {
                dp[i][j] = dp[i - 1][j + 1]; // Вариант как ')', уменьшаем баланс
                if (j > 0) // Если баланс позволяет добавить '('
                    dp[i][j] += dp[i - 1][j - 1]; // Вариант как '(', увеличиваем баланс
            }
        }
    }
}

/// Тесты
void test()
{
    string q1 = ""; // пустая строка
    string q2 = "?"; // 1 символ
    string q3 = "???"; // нечетное количество символов
    string q4 = "????(?"; // кол во методов 2 ()()() (())()
    string q5 = "????"; // кол во методов 2 ()() (())
    vector<vector<int>> dp(100, vector<int>(100));

    dp[0][0] = 1;
    Ans(q1, dp);
    assert(dp[q1.size()][0] == 0);
    dp.clear();


    dp.resize(100);
    for (int i = 0; i < 100; i++)
    {
        dp[i].resize(100);
    }
    dp[0][0] = 1;
    Ans(q2, dp);
    assert(dp[q2.size()][0] == 0);
    dp.clear();


    dp.resize(100);
    for (int i = 0; i < 100; i++)
    {
        dp[i].resize(100);
    }
    dp[0][0] = 1;
    Ans(q3, dp);
    assert(dp[q3.size()][0] == 0);
    dp.clear();


    dp.resize(100);
    for (int i = 0; i < 100; i++)
    {
        dp[i].resize(100);
    }
    dp[0][0] = 1;
    Ans(q4, dp);
    assert(dp[q4.size()][0] == 2);
    dp.clear();


    dp.resize(100);
    for (int i = 0; i < 100; i++)
    {
        dp[i].resize(100);
    }
    dp[0][0] = 1;
    Ans(q5, dp);
    assert(dp[q5.size()][0] == 2);
    dp.clear();
}